#!/bin/bash

# Function to check git status
check_git_status() {
    local dir="$1"
    local project=$(basename "$dir")
    
    if [ -d "$dir/.git" ]; then
        cd "$dir"
        
        # Check for package.json and build:watch command
        local has_package=""
        local build_watch=""
        if [ -f "package.json" ]; then
            has_package="yes"
            # Extract build:watch command using jq if available, otherwise use grep/sed
            if command -v jq &> /dev/null; then
                build_watch=$(jq -r '.scripts."build:watch" // ""' package.json 2>/dev/null)
            else
                build_watch=$(grep -A1 '"build:watch"' package.json 2>/dev/null | grep -o '"[^"]*"' | tail -1 | tr -d '"')
            fi
        fi
        
        # Check for uncommitted changes
        if [ -n "$(git status --porcelain 2>/dev/null)" ]; then
            echo "$project|error|x|$has_package|$build_watch"
            return
        fi
        
        # Check for unpushed commits
        local branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
        if [ -n "$branch" ] && [ "$branch" != "HEAD" ]; then
            local upstream=$(git rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null)
            if [ -n "$upstream" ]; then
                local ahead=$(git rev-list --count @{u}..HEAD 2>/dev/null)
                if [ "$ahead" -gt 0 ]; then
                    echo "$project|error|x|$has_package|$build_watch"
                    return
                fi
            else
                echo "$project|error|x|$has_package|$build_watch"
                return
            fi
        fi
        
        # All good
        echo "$project|ok||$has_package|$build_watch"
    fi
}

# Collect all results first
results=()
for dir in ~/code/*/; do
    if [ -d "$dir" ]; then
        # Skip backups and worktrees directories
        basename_dir=$(basename "$dir")
        if [ "$basename_dir" != "backups" ] && [ "$basename_dir" != "worktrees" ]; then
            result=$(check_git_status "$dir")
            if [ -n "$result" ]; then
                results+=("$result")
            fi
        fi
    fi
done

# Find the longest repo name for proper column width
max_len=10  # Minimum width for "Repository" header
for result in "${results[@]}"; do
    repo_name="${result%%|*}"
    if [ ${#repo_name} -gt $max_len ]; then
        max_len=${#repo_name}
    fi
done

# Print header
printf "%-${max_len}s | %-6s | %-4s | %s\n" "Repository" "Status" "Node" "Build Command"
printf "%s-+-%s-+-%s-+-%s\n" "$(printf '%*s' $max_len | tr ' ' '-')" "------" "----" "-------------"

# Print results
for result in "${results[@]}"; do
    IFS='|' read -r repo state status package build_cmd <<< "$result"
    if [ "$state" = "error" ]; then
        status="x"
    else
        status=""
    fi
    if [ "$package" = "yes" ]; then
        package="x"
    else
        package=""
    fi
    printf "%-${max_len}s | %-6s | %-4s | %s\n" "$repo" "$status" "$package" "$build_cmd"
done