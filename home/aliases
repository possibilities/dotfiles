# Utils
alias vim='nvim'
alias mkdir='mkdir -p'
# note trailing space is needed to support watching aliased commands
alias watch='watch --color --no-title '
alias watchx='watch --color --no-title -x '
alias less='less -R '
alias zh='cat $HOME/.zsh_history'
alias woman='man'

# apps
alias g="git"
alias p="pnpm"
alias t="tmux"
alias ta="tmux attach"
alias tnd="tmux_name_window_after_directory"
alias tn="tmux_name_window"
alias tc="tmux -S /tmp/control-app-tmux"
alias tac="tmux -S /tmp/control-app-tmux attach"
alias a='autocil'
alias grh="grep_history"
alias gsa="git-status-all"

alias misc="git add . ; git ci -am'Misc'"
alias miscpush="git add . ; git ci -am'Misc' ; git push"
alias mp="git add . ; git ci -am'Misc' ; git push"
alias wip="git add .; git commit --no-verify -a -m 'wip [skip ci]'"
alias wipush="git add .; git commit --no-verify -a -m 'wip [skip ci]' ; git push"

alias mr="lab mr create origin develop --assignee possibilities --remove-source-branch --squash"
alias pr="hub pull-request"

alias ls="ls --color=auto"

# vpn
alias vs='nordvpn status'
alias vu='nordvpn connect New_York && nordvpn set killswitch on'
alias vd='nordvpn disconnect'
alias vk='nordvpn set killswitch on'
alias vko='nordvpn set killswitch off'

alias copy='xclip -selection clipboard'
alias clip='xclip -selection clipboard'
alias clipboard='xclip -selection clipboard'

alias claude='~/.claude/local/claude'
alias claude-safe='claude'
alias cs='claude-sessions'
alias claude-upgrade='(
    echo "Checking for Claude updates..." && 
    old_version=$(claude --version 2>/dev/null | grep -oP "\\d+\\.\\d+\\.\\d+") && 
    echo "Current version: $old_version" && 
    cd ~/.claude/local && 
    npm update @anthropic-ai/claude-code && 
    new_version=$(claude --version 2>/dev/null | grep -oP "\\d+\\.\\d+\\.\\d+") && 
    if [ "$old_version" = "$new_version" ]; then 
        echo "No updates available."; 
    else 
        echo "Successfully updated to version $new_version"; 
    fi
)'

bt-connect() {
    local paired_devices=$(bluetoothctl devices Paired | grep -i "headphone\|earphone\|airpod\|buds\|wh-\|wf-")
    
    if [ -z "$paired_devices" ]; then
        echo "No paired headphones found"
        return 1
    fi
    
    echo "$paired_devices" | while read -r line; do
        local mac_address=$(echo "$line" | awk '{print $2}')
        local device_name=$(echo "$line" | cut -d' ' -f3-)
        
        echo "Attempting to connect to $device_name ($mac_address)..."
        bluetoothctl connect "$mac_address" && {
            echo "Successfully connected to $device_name"
            return 0
        }
    done
}

bt-disconnect() {
    local connected_devices=$(bluetoothctl devices Connected | grep -i "headphone\|earphone\|airpod\|buds\|wh-\|wf-")
    
    if [ -z "$connected_devices" ]; then
        echo "No connected headphones found"
        return 1
    fi
    
    echo "$connected_devices" | while read -r line; do
        local mac_address=$(echo "$line" | awk '{print $2}')
        local device_name=$(echo "$line" | cut -d' ' -f3-)
        
        echo "Disconnecting from $device_name ($mac_address)..."
        bluetoothctl disconnect "$mac_address" && {
            echo "Successfully disconnected from $device_name"
        }
    done
}

claude-work() {
    if [ $# -eq 0 ]; then
        dirty-confirm && claude-inject && claude --mcp-config ./.claude/inject-mcps.json
    else
        if [[ ! "$1" =~ ^/ ]]; then
            echo "Error: First argument must start with a slash (/)" >&2
            return 1
        fi
        
        # Extract command name (part after the slash)
        local command_name="${1#/}"
        local command_file="$HOME/.claude/commands/${command_name}.md"
        
        # Check if command file exists
        if [ ! -f "$command_file" ]; then
            echo "Error: Command file not found: $command_file" >&2
            return 1
        fi
        
        dirty-confirm && claude-inject && claude $1 --mcp-config ./.claude/inject-mcps.json ${@:2}
    fi
}

claude-work-continue() {
    dirty-confirm && claude-inject && claude --continue --mcp-config ./.claude/inject-mcps.json ${@:1}
}

commit-work() {
    rm -rf ./.claude ; commit-creator "$@"
}

source $HOME/.worktree-helpers
source $HOME/.session-helpers

gap() {
    local clipboard_content=$(xclip -selection clipboard -o)
    
    if ! echo "$clipboard_content" | grep -q "git apply"; then
        echo "Error: Clipboard doesn't contain a git apply command"
        return 1
    fi
    
    local patch_content=$(echo "$clipboard_content" | sed -n '/^diff --git/,/^EOF/p' | sed '$d')
    
    if [ -z "$patch_content" ]; then
        echo "Error: Could not extract patch content"
        return 1
    fi
    
    echo "$patch_content" | git apply --3way
}

create-new-cli-app() {
    if [ $# -eq 0 ]; then
        echo "Error: create-new-cli-app requires a project name argument" >&2
        echo "Usage: create-new-cli-app <project-name>" >&2
        return 1
    fi
    
    local project_name="$1"
    local source_dir="$HOME/code/commanderjs-template"
    local target_dir="$HOME/code/$project_name"
    
    # Check if source template exists
    if [ ! -d "$source_dir" ]; then
        echo "Error: Template directory not found at $source_dir" >&2
        return 1
    fi
    
    # Check if target directory already exists
    if [ -d "$target_dir" ]; then
        echo "Error: Directory $target_dir already exists" >&2
        return 1
    fi
    
    # Clone the template
    echo "Creating new CLI app: $project_name"
    cp -r "$source_dir" "$target_dir" || {
        echo "Error: Failed to copy template" >&2
        return 1
    }
    
    # Change to the new project directory
    cd "$target_dir" || {
        echo "Error: Failed to cd into $target_dir" >&2
        return 1
    }
    
    # Remove existing .git directory
    rm -rf .git
    
    # Initialize new git repository
    git init
    
    # Create initial commit
    commit-creator || {
        echo "Error: Failed to create initial commit" >&2
        return 1
    }
    
    # Run rebrand command
    claude /rebrand-cli
}

create-new-ui-app() {
    if [ $# -eq 0 ]; then
        echo "Error: create-new-ui-app requires a project name argument" >&2
        echo "Usage: create-new-ui-app <project-name>" >&2
        return 1
    fi
    
    local project_name="$1"
    local source_dir="$HOME/code/nextjs-template"
    local target_dir="$HOME/code/$project_name"
    
    # Check if source template exists
    if [ ! -d "$source_dir" ]; then
        echo "Error: Template directory not found at $source_dir" >&2
        return 1
    fi
    
    # Check if target directory already exists
    if [ -d "$target_dir" ]; then
        echo "Error: Directory $target_dir already exists" >&2
        return 1
    fi
    
    # Clone the template
    echo "Creating new UI app: $project_name"
    cp -r "$source_dir" "$target_dir" || {
        echo "Error: Failed to copy template" >&2
        return 1
    }
    
    # Change to the new project directory
    cd "$target_dir" || {
        echo "Error: Failed to cd into $target_dir" >&2
        return 1
    }
    
    # Remove existing .git directory
    rm -rf .git
    
    # Initialize new git repository
    git init
    
    # Create initial commit
    commit-creator || {
        echo "Error: Failed to create initial commit" >&2
        return 1
    }
    
    # Run rebrand command
    claude /rebrand-ui
}

release-all-projects() {
    local dry_run=false
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --dry-run|-d)
                dry_run=true
                shift
                ;;
            *)
                echo "Error: Unknown option $1" >&2
                echo "Usage: release-all-projects [--dry-run|-d]" >&2
                return 1
                ;;
        esac
    done
    
    if [ "$dry_run" = true ]; then
        echo "=== DRY RUN MODE - No releases will be performed ==="
        echo
    fi
    
    local projects_found=0
    local projects_needing_release=0
    local current_dir=$(pwd)
    local dirty_projects=()
    
    # Iterate through directories in ~/code
    for dir in "$HOME/code"/*; do
        # Skip if not a directory
        [ ! -d "$dir" ] && continue
        
        # Get directory name
        local project_name=$(basename "$dir")
        
        # Skip release-script directory
        [ "$project_name" = "release-script" ] && continue
        
        # Check if release.sh exists
        [ ! -f "$dir/release.sh" ] && continue
        
        # Check if package.json exists
        if [ ! -f "$dir/package.json" ]; then
            echo "Warning: $project_name has release.sh but no package.json, skipping"
            continue
        fi
        
        projects_found=$((projects_found + 1))
        
        # Change to project directory
        cd "$dir" || continue
        
        # Get current version from package.json
        local current_version=$(grep -o '"version":[[:space:]]*"[^"]*"' package.json | sed 's/.*"version":[[:space:]]*"\([^"]*\)".*/\1/')
        
        if [ -z "$current_version" ]; then
            echo "Warning: Could not determine version for $project_name, skipping"
            cd "$current_dir"
            continue
        fi
        
        # Check if there are commits since the last version tag
        local version_tag="v$current_version"
        local commits_since_tag=0
        
        # Check if the version tag exists
        if git rev-parse "$version_tag" >/dev/null 2>&1; then
            commits_since_tag=$(git rev-list "$version_tag"..HEAD --count 2>/dev/null || echo 0)
        else
            # If tag doesn't exist, count all commits
            commits_since_tag=$(git rev-list HEAD --count 2>/dev/null || echo 0)
        fi
        
        if [ "$commits_since_tag" -gt 0 ]; then
            projects_needing_release=$((projects_needing_release + 1))
            echo "ðŸ“¦ $project_name (v$current_version) - $commits_since_tag commits since last release"
            
            # Check if project is dirty (has uncommitted changes)
            if [ "$dry_run" = true ]; then
                if [ -n "$(git status --porcelain)" ]; then
                    dirty_projects+=("$project_name")
                fi
            fi
            
            if [ "$dry_run" = false ]; then
                echo "   Running: pnpm run release:patch"
                pnpm run release:patch
                echo
            else
                echo "   Would run: pnpm run release:patch"
                echo
            fi
        fi
        
        # Return to original directory
        cd "$current_dir"
    done
    
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo "Scanned $projects_found projects with release.sh"
    echo "$projects_needing_release projects need releasing"
    
    if [ "$dry_run" = true ]; then
        if [ ${#dirty_projects[@]} -gt 0 ]; then
            echo
            echo -e "\033[33mâš ï¸  Warning: The following projects have uncommitted changes:\033[0m"
            for project in "${dirty_projects[@]}"; do
                echo -e "\033[33m   - $project\033[0m"
            done
            echo -e "\033[33mCommit or discard changes before releasing these projects.\033[0m"
        fi
        
        if [ "$projects_needing_release" -gt 0 ]; then
            echo
            echo "Run 'release-all-projects' without --dry-run to perform releases"
        fi
    fi
}

comment-destroyer-report() {
    local base_dir="$HOME/code"
    local report_file="$base_dir/docs/comment-destroyer-report.md"
    local current_dir=$(pwd)
    local skipped_projects=()
    
    # Ensure docs directory exists
    mkdir -p "$base_dir/docs"
    
    # Start the report
    echo "# Comment Destroyer Report" > "$report_file"
    echo "Generated on: $(date)" >> "$report_file"
    echo "" >> "$report_file"
    
    # Loop through projects
    for dir in "$base_dir"/*; do
        [ ! -d "$dir" ] && continue
        
        local project_name=$(basename "$dir")
        
        # Skip if no package.json
        [ ! -f "$dir/package.json" ] && continue
        
        cd "$dir" || continue
        
        # Check if git repo is clean
        if [ -n "$(git status --porcelain 2>/dev/null)" ]; then
            skipped_projects+=("$project_name")
            cd "$current_dir"
            continue
        fi
        
        # Run comment-destroyer
        echo "Processing $project_name..."
        comment-destroyer 2>/dev/null
        
        # Capture the diff
        local diff_output=$(git diff)
        
        if [ -n "$diff_output" ]; then
            echo "## $project_name" >> "$report_file"
            echo '```diff' >> "$report_file"
            echo "$diff_output" >> "$report_file"
            echo '```' >> "$report_file"
            echo "" >> "$report_file"
        fi
        
        # Revert changes
        git reset --hard >/dev/null 2>&1
        
        cd "$current_dir"
    done
    
    # Add skipped projects section
    if [ ${#skipped_projects[@]} -gt 0 ]; then
        echo "## Skipped Projects (Dirty)" >> "$report_file"
        echo "" >> "$report_file"
        echo "The following projects were skipped because they had uncommitted changes:" >> "$report_file"
        echo "" >> "$report_file"
        for project in "${skipped_projects[@]}"; do
            echo "- $project" >> "$report_file"
        done
    fi
    
    echo "Report generated at: $report_file"
}

update-release-scripts() {
    local source_release="$HOME/code/release-script/release.sh"
    local current_dir=$(pwd)
    local updated_projects=()
    local dirty_projects=()
    local projects_checked=0
    local projects_updated=0
    
    # Check if source release.sh exists
    if [ ! -f "$source_release" ]; then
        echo "Error: Source release.sh not found at $source_release" >&2
        return 1
    fi
    
    echo "Updating release.sh files across all projects..."
    echo
    
    # Find all projects with release.sh
    for dir in "$HOME/code"/*; do
        [ ! -d "$dir" ] && continue
        
        local project_name=$(basename "$dir")
        local project_release="$dir/release.sh"
        
        # Skip if no release.sh exists
        [ ! -f "$project_release" ] && continue
        
        projects_checked=$((projects_checked + 1))
        
        # Compare with source
        if cmp -s "$source_release" "$project_release"; then
            # Files are identical, skip
            continue
        fi
        
        # Files are different, need to update
        cd "$dir" || continue
        
        # Check if repo is dirty
        if [ -n "$(git status --porcelain 2>/dev/null)" ]; then
            dirty_projects+=("$project_name")
            cd "$current_dir"
            continue
        fi
        
        # Copy the new release.sh
        echo "ðŸ“ Updating release.sh in $project_name"
        cp "$source_release" "$project_release" || {
            echo "Error: Failed to copy release.sh to $project_name" >&2
            cd "$current_dir"
            continue
        }
        
        # Create commit
        commit-creator || {
            echo "Error: Failed to create commit in $project_name" >&2
            # Revert the change
            git reset --hard >/dev/null 2>&1
            cd "$current_dir"
            continue
        }
        
        updated_projects+=("$project_name")
        projects_updated=$((projects_updated + 1))
        
        cd "$current_dir"
    done
    
    # Summary
    echo
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo "âœ… Checked $projects_checked projects with release.sh"
    echo "ðŸ“¦ Updated $projects_updated projects"
    
    if [ ${#updated_projects[@]} -gt 0 ]; then
        echo
        echo "Updated projects:"
        for project in "${updated_projects[@]}"; do
            echo "  - $project"
        done
    fi
    
    if [ ${#dirty_projects[@]} -gt 0 ]; then
        echo
        echo -e "\033[31mâš ï¸  The following projects were skipped due to uncommitted changes:\033[0m"
        for project in "${dirty_projects[@]}"; do
            echo -e "\033[31m  - $project\033[0m"
        done
        echo -e "\033[31mCommit or discard changes in these projects before updating release.sh\033[0m"
    fi
}

git-grep-all() {
    if [ $# -eq 0 ]; then
        echo "Error: git-grep-all requires arguments to pass to git grep" >&2
        echo "Usage: git-grep-all <git-grep-arguments>" >&2
        return 1
    fi
    
    local current_dir=$(pwd)
    local timestamp=$(date +%Y%m%d_%H%M%S)
    local output_file="/tmp/git-grep-all-${timestamp}.md"
    local repos_searched=0
    local repos_with_results=0
    
    # Create markdown header
    echo "# Git Grep Results" > "$output_file"
    echo "Generated: $(date)" >> "$output_file"
    echo "Search arguments: \`git grep $@\`" >> "$output_file"
    echo "" >> "$output_file"
    
    echo "Searching all git repositories in ~/code..."
    
    # Find all directories with .git
    for dir in "$HOME/code"/*; do
        [ ! -d "$dir/.git" ] && continue
        
        local project_name=$(basename "$dir")
        cd "$dir" || continue
        
        repos_searched=$((repos_searched + 1))
        
        # Run git grep and capture output
        local grep_output=$(git grep "$@" 2>/dev/null)
        
        if [ -n "$grep_output" ]; then
            repos_with_results=$((repos_with_results + 1))
            echo "Found matches in: $project_name"
            
            # Add to markdown
            echo "## $project_name" >> "$output_file"
            echo '```' >> "$output_file"
            echo "$grep_output" >> "$output_file"
            echo '```' >> "$output_file"
            echo "" >> "$output_file"
        fi
        
        cd "$current_dir"
    done
    
    # Add summary
    echo "" >> "$output_file"
    echo "---" >> "$output_file"
    echo "Searched $repos_searched repositories, found results in $repos_with_results" >> "$output_file"
    
    if [ "$repos_with_results" -eq 0 ]; then
        echo "No matches found in any repository"
        rm "$output_file"
        return 0
    fi
    
    # Create gist and show notification
    echo "Creating gist..."
    gist "$output_file" --open &
    
    notify-send "Git Grep Complete" "Found results in $repos_with_results repositories. Gist created and opened."
    
    echo
    echo "Results saved to: $output_file"
    echo "Gist created and opened in browser"
}
